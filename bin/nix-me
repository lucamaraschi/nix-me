#!/bin/bash

# nix-me - Interactive Nix Configuration Manager
# A user-friendly CLI for managing macOS configurations with nix-darwin

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="$SCRIPT_DIR/../lib"

# Detect CONFIG_DIR - prefer current project if running from nix-me repo
if [[ -f "$SCRIPT_DIR/../flake.nix" ]]; then
    CONFIG_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
elif [[ -d "${HOME}/.config/nixpkgs" ]]; then
    CONFIG_DIR="${HOME}/.config/nixpkgs"
else
    CONFIG_DIR="${HOME}/.config/nixpkgs"  # Default even if doesn't exist
fi

# Source libraries
source "$LIB_DIR/ui.sh"
source "$LIB_DIR/config-builder.sh" 2>/dev/null || true
source "$LIB_DIR/package-manager.sh" 2>/dev/null || true
source "$LIB_DIR/config-wizard.sh" 2>/dev/null || true
source "$LIB_DIR/vm-manager.sh" 2>/dev/null || true
source "$LIB_DIR/tui.sh" 2>/dev/null || true

# ============================================================================
# Help and Documentation
# ============================================================================

show_help() {
    print_header "nix-me - Nix Configuration Manager"
    cat << EOF

${CYAN}Usage:${NC} nix-me <command> [options]

${CYAN}Configuration Commands:${NC}
  ${GREEN}create${NC}              Create new machine configuration (wizard)
  ${GREEN}setup${NC}               Alias for 'create'
  ${GREEN}reconfigure${NC} [host]  Modify existing configuration
  ${GREEN}clone${NC} <from> <to>   Clone configuration to new machine

${CYAN}Package Management:${NC}
  ${GREEN}browse${NC}              Browse and add apps interactively
  ${GREEN}search${NC} <query>      Search for apps
  ${GREEN}add${NC} <type> <name>   Add specific package
  ${GREEN}remove${NC} <type> <name> Remove package (interactive)

${CYAN}System Management:${NC}
  ${GREEN}switch${NC}              Apply configuration changes
  ${GREEN}build${NC}               Build configuration (test only)
  ${GREEN}update${NC}              Update packages
  ${GREEN}rollback${NC}            Rollback to previous configuration

${CYAN}VM Management:${NC}
  ${GREEN}vm${NC}                  Interactive VM management menu
  ${GREEN}vm create${NC}           Create new VM (Omarchy/NixOS/Ubuntu)
  ${GREEN}vm list${NC}             List VMs
  ${GREEN}vm start${NC}            Start a VM
  ${GREEN}vm stop${NC}             Stop a VM
  ${GREEN}vm delete${NC}           Delete a VM

${CYAN}Information:${NC}
  ${GREEN}status${NC}              Show system status
  ${GREEN}doctor${NC}              Diagnose configuration issues
  ${GREEN}list${NC}                List installed packages
  ${GREEN}diff${NC}                Show package changes (what will be added/removed)

${CYAN}Package Types:${NC}
  ${GREEN}app${NC} <name>          GUI application (Homebrew cask)
  ${GREEN}tool${NC} <name>         CLI tool (Nix package)

${CYAN}Examples:${NC}
  ${YELLOW}# Create new configuration${NC}
  nix-me create

  ${YELLOW}# Browse and add apps interactively${NC}
  nix-me browse

  ${YELLOW}# Search for specific apps${NC}
  nix-me search docker

  ${YELLOW}# Add specific app${NC}
  nix-me add app spotify

  ${YELLOW}# Apply changes${NC}
  nix-me switch

  ${YELLOW}# Check system health${NC}
  nix-me doctor

  ${YELLOW}# Manage VMs${NC}
  nix-me vm

  ${YELLOW}# Create new Omarchy VM${NC}
  nix-me vm create

  ${YELLOW}# Open interactive menu${NC}
  nix-me
  nix-me menu

${CYAN}For more help:${NC} nix-me <command> --help

EOF
}

# ============================================================================
# Configuration Commands
# ============================================================================

cmd_create() {
    run_configuration_wizard
}

cmd_reconfigure() {
    local hostname="${1:-$(hostname -s | tr '[:upper:]' '[:lower:]')}"
    reconfigure_machine "$hostname"
}

# ============================================================================
# Package Management Commands
# ============================================================================

cmd_browse() {
    print_header "Browse Applications"
    echo ""

    if ! command -v fzf &>/dev/null; then
        print_error "fzf is required for interactive browsing"
        print_info "Install with: nix-me add tool fzf"
        return 1
    fi

    echo "  ${CYAN}1${NC}) Browse all applications"
    echo "  ${CYAN}2${NC}) Browse by category"
    echo "  ${CYAN}3${NC}) Search specific apps"
    echo ""

    read -p "Choice [1]: " choice
    choice=${choice:-1}

    case $choice in
        1)
            local selected=$(browse_homebrew_casks_fzf "")
            ;;
        2)
            local selected=$(browse_by_category)
            ;;
        3)
            read -p "Search for: " query
            local selected=$(browse_homebrew_casks_fzf "$query")
            ;;
        *)
            print_error "Invalid choice"
            return 1
            ;;
    esac

    if [ -n "$selected" ]; then
        local packages=()
        readarray -t packages <<< "$selected"

        # Get list of installed casks to show status
        local installed_casks=$(brew list --cask 2>/dev/null | sort)

        print_info "Selected ${#packages[@]} apps:"
        for pkg in "${packages[@]}"; do
            if echo "$installed_casks" | grep -q "^${pkg}$"; then
                echo -e "  ${GREEN}✓${NC} $pkg ${YELLOW}(already installed)${NC}"
            else
                echo "  ${GREEN}•${NC} $pkg"
            fi
        done
        echo ""

        local hostname=$(hostname -s | tr '[:upper:]' '[:lower:]')
        add_casks_to_config "$hostname" "${packages[@]}"

        if [ $? -eq 2 ]; then
            cmd_switch
        fi
    fi
}

cmd_search() {
    local query="$1"

    if [ -z "$query" ]; then
        print_error "Please provide a search term"
        echo "Usage: nix-me search <query>"
        return 1
    fi

    if ! command -v fzf &>/dev/null; then
        print_warn "fzf not available, showing simple results"
        brew search --cask "$query" 2>/dev/null | head -20
        return 0
    fi

    local selected=$(browse_homebrew_casks_fzf "$query")

    if [ -n "$selected" ]; then
        local packages=()
        readarray -t packages <<< "$selected"

        # Get list of installed casks to show status
        local installed_casks=$(brew list --cask 2>/dev/null | sort)

        print_info "Selected ${#packages[@]} apps:"
        for pkg in "${packages[@]}"; do
            if echo "$installed_casks" | grep -q "^${pkg}$"; then
                echo -e "  ${GREEN}✓${NC} $pkg ${YELLOW}(already installed)${NC}"
            else
                echo "  ${GREEN}•${NC} $pkg"
            fi
        done
        echo ""

        if ask_yes_no "Add these to your configuration?" "y"; then
            local hostname=$(hostname -s | tr '[:upper:]' '[:lower:]')
            add_casks_to_config "$hostname" "${packages[@]}"

            if [ $? -eq 2 ]; then
                cmd_switch
            fi
        fi
    fi
}

cmd_add_app() {
    local app_name="$1"

    if [ -z "$app_name" ]; then
        # No app specified, show interactive browser
        cmd_browse
        return $?
    fi

    # Specific app requested
    cmd_search "$app_name"
}

cmd_add_tool() {
    local tool_name="$1"

    if [ -z "$tool_name" ]; then
        print_error "Please specify a tool name"
        echo "Usage: nix-me add tool <name>"
        return 1
    fi

    print_header "Adding CLI Tool"
    print_info "Tool: $tool_name"
    echo ""

    # Check if tool exists in nixpkgs
    print_info "Searching nixpkgs..."
    local search_result=$(nix search nixpkgs "$tool_name" --json 2>/dev/null | jq -r 'keys[0]' 2>/dev/null)

    if [ -n "$search_result" ]; then
        local package_name=$(echo "$search_result" | cut -d'.' -f2)
        print_success "Found: $package_name"
    else
        print_warn "Package not found in nixpkgs, using provided name"
        local package_name="$tool_name"
    fi

    echo ""
    print_info "To add this tool, edit:"
    echo "  ${CYAN}$CONFIG_DIR/modules/darwin/apps/installations.nix${NC}"
    echo ""
    echo "Add to systemPackages array:"
    echo "  ${GREEN}\"$package_name\"${NC}"
    echo ""

    if ask_yes_no "Open installations.nix in editor?" "y"; then
        ${EDITOR:-nano} "$CONFIG_DIR/modules/darwin/apps/installations.nix"
    fi

    echo ""
    if ask_yes_no "Apply changes now?" "y"; then
        cmd_switch
    else
        print_info "Run 'nix-me switch' when ready to apply changes"
    fi
}

cmd_remove() {
    print_warn "Remove functionality coming soon"
    print_info "For now, manually edit configuration files:"
    echo "  ${CYAN}$CONFIG_DIR/hosts/<hostname>/default.nix${NC}"
    echo "  ${CYAN}$CONFIG_DIR/modules/darwin/apps/installations.nix${NC}"
}

# ============================================================================
# System Management Commands
# ============================================================================

cmd_switch() {
    print_header "Applying Configuration"

    if [ ! -d "$CONFIG_DIR" ]; then
        print_error "Configuration directory not found: $CONFIG_DIR"
        return 1
    fi

    cd "$CONFIG_DIR" || exit 1

    print_info "Building and applying configuration..."
    echo ""

    if make switch; then
        print_success "Configuration applied successfully!"
        echo ""
        print_info "Your system has been updated"
    else
        print_error "Failed to apply configuration"
        print_info "Check the error messages above for details"
        return 1
    fi
}

cmd_build() {
    print_header "Building Configuration (Test Mode)"

    if [ ! -d "$CONFIG_DIR" ]; then
        print_error "Configuration directory not found: $CONFIG_DIR"
        return 1
    fi

    cd "$CONFIG_DIR" || exit 1

    print_info "Building configuration (no changes will be applied)..."
    echo ""

    if make build; then
        print_success "Configuration builds successfully!"
    else
        print_error "Configuration has errors"
        return 1
    fi
}

cmd_update() {
    print_header "Updating System"

    if [ ! -d "$CONFIG_DIR" ]; then
        print_error "Configuration directory not found: $CONFIG_DIR"
        return 1
    fi

    cd "$CONFIG_DIR" || exit 1

    print_info "Updating flake inputs..."
    nix flake update --extra-experimental-features "nix-command flakes"

    echo ""
    if ask_yes_no "Apply updates now?" "y"; then
        cmd_switch
    else
        print_info "Run 'nix-me switch' to apply updates later"
    fi
}

cmd_rollback() {
    print_header "Rollback Configuration"

    print_info "Available generations:"
    darwin-rebuild --list-generations 2>/dev/null | tail -5

    echo ""
    read -p "Rollback to previous generation? (y/N): " confirm

    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        print_info "Rolling back..."
        sudo darwin-rebuild switch --rollback

        if [ $? -eq 0 ]; then
            print_success "Successfully rolled back to previous generation"
        else
            print_error "Rollback failed"
            return 1
        fi
    else
        print_info "Rollback cancelled"
    fi
}

# ============================================================================
# Information Commands
# ============================================================================

cmd_status() {
    clear
    print_header "System Status"
    echo ""

    print_step "1/5" "Configuration Location"
    if [ -d "$CONFIG_DIR" ]; then
        print_success "Configuration found at: $CONFIG_DIR"
        local branch=$(cd "$CONFIG_DIR" && git branch --show-current 2>/dev/null)
        print_info "Git branch: ${branch:-unknown}"
    else
        print_error "Configuration not found at: $CONFIG_DIR"
    fi
    echo ""

    print_step "2/5" "Current Machine"
    local hostname=$(hostname -s | tr '[:upper:]' '[:lower:]')
    print_info "Hostname: $hostname"

    if [ -d "$CONFIG_DIR/hosts/$hostname" ]; then
        print_success "Configuration exists for this machine"
    else
        print_warn "No configuration found for this hostname"
    fi
    echo ""

    print_step "3/5" "Nix Generation"
    local current_gen=$(darwin-rebuild --list-generations 2>/dev/null | tail -1 || echo "unknown")
    print_info "Current: $current_gen"
    echo ""

    print_step "4/5" "Installed Packages"
    local brew_count=$(brew list --cask 2>/dev/null | wc -l | tr -d ' ' || echo "0")
    local nix_count=$(ls /nix/var/nix/profiles/system/sw/bin 2>/dev/null | wc -l | tr -d ' ' || echo "0")
    print_info "Homebrew casks: $brew_count"
    print_info "Nix packages: $nix_count"
    echo ""

    print_step "5/5" "Disk Usage"
    local store_size=$(du -sh /nix/store 2>/dev/null | cut -f1 || echo "unknown")
    print_info "Nix store size: $store_size"
}

cmd_doctor() {
    print_header "System Diagnostics"
    echo ""

    local issues=0

    # Check Nix installation
    print_step "1/8" "Checking Nix installation"
    if command -v nix &>/dev/null; then
        local nix_version=$(nix --version 2>/dev/null || echo "unknown")
        print_success "Nix is installed: $nix_version"
    else
        print_error "Nix is not installed"
        ((issues++))
    fi
    echo ""

    # Check nix-darwin
    print_step "2/8" "Checking nix-darwin"
    if command -v darwin-rebuild &>/dev/null; then
        print_success "nix-darwin is installed"
    else
        print_error "nix-darwin is not installed"
        ((issues++))
    fi
    echo ""

    # Check configuration
    print_step "3/8" "Validating configuration"
    if [ -d "$CONFIG_DIR" ]; then
        print_success "Configuration directory exists"
        cd "$CONFIG_DIR" 2>/dev/null
        if make check &>/dev/null 2>&1; then
            print_success "Configuration is valid"
        else
            print_warn "Configuration may have errors (run 'make check' for details)"
        fi
    else
        print_error "Configuration directory not found"
        ((issues++))
    fi
    echo ""

    # Check Homebrew
    print_step "4/8" "Checking Homebrew"
    if command -v brew &>/dev/null; then
        print_success "Homebrew is installed"
        local outdated=$(brew outdated 2>/dev/null | wc -l | tr -d ' ')
        if [ "$outdated" -gt 0 ]; then
            print_info "Outdated packages: $outdated"
        fi
    else
        print_warn "Homebrew is not installed"
    fi
    echo ""

    # Check fzf
    print_step "5/8" "Checking interactive tools"
    if command -v fzf &>/dev/null; then
        print_success "fzf is installed (interactive features available)"
    else
        print_warn "fzf not installed (interactive features limited)"
        print_info "Install with: nix-me add tool fzf"
    fi
    echo ""

    # Check 1Password SSH
    print_step "6/8" "Checking 1Password SSH agent"
    local onepass_socket="$HOME/Library/Group Containers/2BUA8C4S2C.com.1password/t/agent.sock"
    if [ -S "$onepass_socket" ]; then
        print_success "1Password SSH agent is available"
        if ssh-add -l &>/dev/null 2>&1; then
            local key_count=$(ssh-add -l 2>/dev/null | wc -l | tr -d ' ')
            print_info "Keys available: $key_count"
        fi
    else
        print_info "1Password SSH agent not found (optional)"
    fi
    echo ""

    # Check disk space
    print_step "7/8" "Checking disk space"
    local available=$(df -h / | tail -1 | awk '{print $4}')
    local used_percent=$(df -h / | tail -1 | awk '{print $5}')
    print_info "Available space: $available (${used_percent} used)"

    local store_size=$(du -sh /nix/store 2>/dev/null | cut -f1 || echo "unknown")
    print_info "Nix store size: $store_size"
    echo ""

    # Check for common issues
    print_step "8/8" "Common issues"

    if [ -d "$CONFIG_DIR/.git" ]; then
        cd "$CONFIG_DIR"
        if ! git diff --quiet HEAD 2>/dev/null; then
            print_warn "Uncommitted changes in configuration"
            ((issues++))
        fi
    fi

    if ! pgrep nix-daemon &>/dev/null; then
        print_warn "Nix daemon may not be running"
        ((issues++))
    fi

    if [ $issues -eq 0 ]; then
        print_success "No issues detected"
    else
        print_warn "Found $issues potential issues"
    fi
    echo ""

    print_header "Diagnostics Complete"

    if [ $issues -eq 0 ]; then
        echo ""
        print_success "✅ Your system is healthy!"
    fi
}

cmd_list() {
    print_header "Installed Packages"
    echo ""

    print_step "1/2" "Homebrew Casks (GUI Apps)"
    if command -v brew &>/dev/null; then
        local cask_count=$(brew list --cask 2>/dev/null | wc -l | tr -d ' ')
        echo "Total: $cask_count"
        echo ""
        brew list --cask 2>/dev/null | sort | while read cask; do
            echo -e "  ${GREEN}✓${NC} $cask"
        done
    else
        print_warn "Homebrew not installed"
    fi
    echo ""

    print_step "2/2" "Nix Packages (CLI Tools)"
    if [ -d "/nix/var/nix/profiles/system/sw/bin" ]; then
        local tool_count=$(ls /nix/var/nix/profiles/system/sw/bin 2>/dev/null | wc -l | tr -d ' ')
        echo "Total: $tool_count"
        echo ""
        ls /nix/var/nix/profiles/system/sw/bin 2>/dev/null | sort | head -50 | while read tool; do
            echo -e "  ${GREEN}✓${NC} $tool"
        done
    else
        print_warn "Nix not installed"
    fi
}

cmd_diff() {
    # Run the package diff tool in interactive mode
    "$LIB_DIR/diff-packages.sh" interactive
}

# ============================================================================
# Main Command Router
# ============================================================================

case "${1:-menu}" in
    # Main interactive menu (default)
    menu|"")
        # Try Node TUI first (using npx tsx for development), fallback to bash TUI
        if [[ -f "$SCRIPT_DIR/../tui/src/index.tsx" ]] && command -v npx &>/dev/null; then
            cd "$SCRIPT_DIR/../tui" && exec npx tsx src/index.tsx
        elif [[ -x "$SCRIPT_DIR/../tui/dist/index.js" ]] && command -v node &>/dev/null; then
            exec node "$SCRIPT_DIR/../tui/dist/index.js"
        elif type main_menu &>/dev/null; then
            main_menu
        else
            show_help
        fi
        ;;

    # Configuration commands
    create|setup)
        cmd_create
        ;;
    reconfigure)
        shift
        cmd_reconfigure "$@"
        ;;

    # Package management
    browse)
        cmd_browse
        ;;
    search)
        shift
        cmd_search "$@"
        ;;
    add)
        shift
        type="$1"
        shift
        case "$type" in
            app) cmd_add_app "$@" ;;
            tool) cmd_add_tool "$@" ;;
            *) print_error "Unknown type: $type"; show_help; exit 1 ;;
        esac
        ;;
    remove)
        shift
        cmd_remove "$@"
        ;;

    # System management
    switch)
        cmd_switch
        ;;
    build)
        cmd_build
        ;;
    update)
        cmd_update
        ;;
    rollback)
        cmd_rollback
        ;;

    # VM Management
    vm)
        shift
        case "${1:-menu}" in
            menu|"")
                vm_main_menu
                ;;
            create)
                vm_create_wizard
                ;;
            list)
                vm_list
                ;;
            start)
                vm_start_menu
                ;;
            stop)
                vm_stop_menu
                ;;
            delete)
                vm_delete_menu
                ;;
            *)
                print_error "Unknown vm subcommand: $1"
                echo "Available: create, list, start, stop, delete"
                exit 1
                ;;
        esac
        ;;

    # Information
    status)
        cmd_status
        ;;
    doctor)
        cmd_doctor
        ;;
    list)
        cmd_list
        ;;
    diff)
        cmd_diff
        ;;

    # Help
    help|--help|-h)
        show_help
        ;;

    *)
        print_error "Unknown command: $1"
        echo ""
        show_help
        exit 1
        ;;
esac
